        -:    0:Source:/home/krillin/code/nsu/23203_knyazkov/lab1/src/hashtable.cpp
        -:    0:Graph:/home/krillin/code/nsu/23203_knyazkov/lab1/test/build/CMakeFiles/TestCoverage.dir/src/all_tests.gcno
        -:    0:Data:/home/krillin/code/nsu/23203_knyazkov/lab1/test/build/CMakeFiles/TestCoverage.dir/src/all_tests.gcda
        -:    0:Runs:2
        -:    1:#include "hashtable.h"
        -:    2:
        -:    3:#include <algorithm>
        -:    4:#include <cstddef>
        -:    5:#include <cstdint>
        -:    6:#include <iostream>
        -:    7:#include <stdexcept>
        -:    8:
        -:    9:/*--------CONSTRUCTORS---------*/
        -:   10:
function _ZN9HashTableC2Ev called 72 returned 100% blocks executed 86%
       72:   11:HashTable::HashTable()
      72*:   12:    : capacity(DEF_CAPACITY), table(new HashNode *[capacity]) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
call    3 returned 100%
       72:   13:  std::fill(table, table + capacity, nullptr);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       72:   14:};
        -:   15:
function _ZN9HashTableD2Ev called 172 returned 100% blocks executed 100%
      172:   16:HashTable::~HashTable() {
      172:   17:  if (table != nullptr) {
branch  0 taken 59% (fallthrough)
branch  1 taken 41%
      102:   18:    deleteTable();
call    0 returned 100%
        -:   19:  }
      172:   20:};
        -:   21:
function _ZN9HashTableC2ERKS_ called 2 returned 100% blocks executed 83%
        2:   22:HashTable::HashTable(const HashTable &other)
        2:   23:    : capacity(other.capacity), size(other.size),
       2*:   24:      table(new HashNode *[capacity]) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
call    3 returned 100%
        2:   25:  std::transform(
        2:   26:      other.table, other.table + capacity, table,
call    0 returned 100%
function _ZZN9HashTableC4ERKS_ENKUlPNS_8HashNodeEE_clES3_ called 20 returned 100% blocks executed 73%
       20:   27:      [](HashNode *node) { return node ? new HashNode(*node) : nullptr; });
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
branch  8 never executed (fallthrough)
branch  9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed
call   12 never executed
        2:   28:};
        -:   29:
function _ZN9HashTableC2Em called 98 returned 96% blocks executed 77%
       98:   30:HashTable::HashTable(size_t init_capacity) {
       98:   31:  if (init_capacity == 0) {
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        4:   32:    throw std::invalid_argument("nope");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 0%
call    5 never executed
        -:   33:  }
       94:   34:  capacity = init_capacity;
      94*:   35:  table = new HashNode *[capacity];
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
call    3 returned 100%
       94:   36:  std::fill(table, table + capacity, nullptr);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       94:   37:};
        -:   38:
function _ZN9HashTableC2EOS_ called 4 returned 100% blocks executed 100%
        4:   39:HashTable::HashTable(HashTable &&other)
        4:   40:    : capacity(other.capacity), size(other.size), table(other.table) {
        4:   41:  other.table = nullptr;
        4:   42:  other.capacity = 0;
        4:   43:  other.size = 0;
        4:   44:};
        -:   45:
        -:   46:/*--------METHODS---------*/
        -:   47:
        -:   48:// // magic 33 (hashing func for string key)
        -:   49:// size_t HashTable::hash(const Key &key) const {
        -:   50://   uint64_t hash = 5381;
        -:   51:
        -:   52://   for (auto c : key){
        -:   53://     hash = ((hash << 5) + hash) + c; // hash * 33 + c
        -:   54://   }
        -:   55:
        -:   56://   return hash % capacity;
        -:   57:// }
        -:   58:
function _ZNK9HashTable4hashERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 3098 returned 100% blocks executed 100%
     3098:   59:size_t HashTable::hash(const Key &key) const { return 1 % capacity; }
        -:   60:
function _ZNK9HashTable13getLoadFactorEv called 2622 returned 100% blocks executed 100%
     2622:   61:double HashTable::getLoadFactor() const {
     2622:   62:  return static_cast<double>(size) / (capacity);
        -:   63:}
        -:   64:
function _ZN9HashTable11deleteTableEv called 120 returned 100% blocks executed 100%
      120:   65:void HashTable::deleteTable() {
     3444:   66:  for (size_t i = 0; i < capacity; i++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
     3324:   67:    if (table[i] != nullptr) {
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
      606:   68:      delete table[i];
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
        -:   69:    }
        -:   70:  }
      120:   71:  delete[] table;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
      120:   72:}
        -:   73:
        -:   74:// if MAX_LOAD_FACTOR is exceeded double the size
        -:   75:// and rehash everything to the new table
function _ZN9HashTable14rehashIfNeededEv called 2622 returned 100% blocks executed 91%
     2622:   76:void HashTable::rehashIfNeeded() {
     2622:   77:  const double load_factor = getLoadFactor();
call    0 returned 100%
     2622:   78:  if ((load_factor < MAX_LOAD_FACTOR) ||
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
       62:   79:      (capacity >= SIZE_MAX / CAPACITY_MULTIPLIER)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     2560:   80:    return;
        -:   81:  }
       62:   82:  const size_t old_capacity = capacity;
       62:   83:  capacity *= CAPACITY_MULTIPLIER;
       62:   84:  HashTable newTable(capacity);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:   85:
     2474:   86:  for (size_t i = 0; i < old_capacity; i++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
     2412:   87:    if (table[i] != nullptr) {
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
     1456:   88:      newTable.insert(table[i]->key, table[i]->value);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
     1456:   89:      delete table[i];
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
     1456:   90:      table[i] = nullptr;
        -:   91:    }
        -:   92:  }
       62:   93:  delete[] table;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
       62:   94:  table = nullptr;
       62:   95:  std::swap(table, newTable.table);
call    0 returned 100%
       62:   96:}
call    0 returned 100%
call    1 never executed
        -:   97:
function _ZNK9HashTable4findERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 448 returned 100% blocks executed 100%
      448:   98:size_t HashTable::find(const Key &k) const {
      448:   99:  size_t hashed_index = hash(k);
call    0 returned 100%
      448:  100:  size_t index = hashed_index;
        -:  101:
      448:  102:  if (table[hashed_index] != nullptr && table[hashed_index]->key == k) {
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
call    2 returned 100%
branch  3 taken 73% (fallthrough)
branch  4 taken 27%
branch  5 taken 7% (fallthrough)
branch  6 taken 93%
       32:  103:    return index;
        -:  104:  } else {
      416:  105:    index = linearProbing(index, k, SearchType::SEARCH_FOR_KEY);
call    0 returned 100%
        -:  106:  }
      416:  107:  return index;
        -:  108:}
        -:  109:
        -:  110:// delete element by key k
        -:  111:// return if it was successuful (key is found and deleted)
function _ZN9HashTable5eraseERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 414 returned 100% blocks executed 100%
      414:  112:bool HashTable::erase(const Key &k) {
      414:  113:  const size_t index = find(k);
call    0 returned 100%
      414:  114:  if (index == capacity) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        2:  115:    return false;
        -:  116:  }
      412:  117:  std::clog << "> deleting " << k << std::endl;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  118:
      412:  119:  delete table[index];
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
      412:  120:  table[index] = nullptr; // node is deleted = nullptr
      412:  121:  size--;
      412:  122:  return true;
        -:  123:}
        -:  124:
        -:  125:// collission resolution:
        -:  126:// lineary go through table and search for empty/free or with the same key node
        -:  127:// index = capacity => index wasn't found (no bucket with key or buckets are
        -:  128:// full)
function _ZNK9HashTable13linearProbingEmRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS_10SearchTypeE called 2766 returned 100% blocks executed 100%
     2766:  129:size_t HashTable::linearProbing(size_t startIndex, Key const &key, SearchType searchT) const {
     2766:  130:  size_t curIndex = startIndex;
        -:  131:
   108874:  132:  for (size_t i = 0; i <= capacity; i++) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
   130724:  133:    if ((searchT == SearchType::SEARCH_FOR_NULLPTR && table[curIndex] == nullptr) ||
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
branch  2 taken 97% (fallthrough)
branch  3 taken 3%
branch  4 taken 21% (fallthrough)
branch  5 taken 79%
branch  6 taken 3% (fallthrough)
branch  7 taken 97%
    30058:  134:        (searchT == SearchType::SEARCH_FOR_KEY && table[curIndex] != nullptr &&
branch  0 taken 37% (fallthrough)
branch  1 taken 63%
branch  2 taken 5% (fallthrough)
branch  3 taken 95%
     8194:  135:         table[curIndex]->key == key)) {
call    0 returned 100%
     2752:  136:      return curIndex; // Return the current index if the condition is met
        -:  137:    }
   106108:  138:    curIndex = (curIndex + i) % capacity;
        -:  139:  }
       14:  140:  return capacity;
        -:  141:}
        -:  142:
        -:  143:// insertion using linear probing collision resolution
        -:  144:// inserts node to container (return if it was success)
        -:  145:// otherwise, search for the first empty node (linear probing)
function _ZN9HashTable6insertERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERK5Value called 2622 returned 100% blocks executed 79%
     2622:  146:bool HashTable::insert(const Key &k, const Value &v) {
     2622:  147:  rehashIfNeeded();
call    0 returned 100%
     2622:  148:  size_t index = hash(k);
call    0 returned 100%
        -:  149:  // if node is not empty or doesn't have the same key
     2622:  150:  if (!(table[index] == nullptr) && !(table[index]->key == k)) {
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
call    2 returned 100%
branch  3 taken 94% (fallthrough)
branch  4 taken 6%
branch  5 taken 89% (fallthrough)
branch  6 taken 11%
     2322:  151:    index = linearProbing(index, k, SearchType::SEARCH_FOR_NULLPTR); // collission resolution
call    0 returned 100%
        -:  152:  }
        -:  153:  // if index was found
     2622:  154:  if (index != capacity) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2622:  155:    if (table[index] == nullptr) {
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
     2464:  156:      table[index] = new HashNode(k, v);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
branch  9 never executed (fallthrough)
branch 10 never executed
call   11 never executed
     2464:  157:      ++size;
     2464:  158:      return true;
        -:  159:    }
        -:  160:  }
      158:  161:  return false;
        -:  162:}
        -:  163:
function _ZNK9HashTable2atERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 16 returned 75% blocks executed 71%
       16:  164:const Value &HashTable::at(const Key &k) const {
       16:  165:  const size_t index = find(k);
call    0 returned 100%
       16:  166:  if (index == capacity) {
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        4:  167:    throw std::runtime_error("Key not found: " + k);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 0%
call    9 never executed
call   10 never executed
        -:  168:  }
       12:  169:  return table[index]->value;
        -:  170:}
        -:  171:
function _ZN9HashTable2atERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 8 returned 50% blocks executed 100%
        8:  172:Value &HashTable::at(const Key &k) {
        8:  173:  return const_cast<Value &>(static_cast<const HashTable *>(this)->at(k));
call    0 returned 50%
        -:  174:}
        -:  175:
function _ZNK9HashTable8containsERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 18 returned 100% blocks executed 100%
       18:  176:bool HashTable::contains(const Key &key) const {
       18:  177:  return (find(key) != capacity);
call    0 returned 100%
        -:  178:}
        -:  179:
function _ZN9HashTable5clearEv called 10 returned 100% blocks executed 88%
       10:  180:void HashTable::clear() {
       10:  181:  deleteTable();
call    0 returned 100%
      10*:  182:  table = new HashNode *[capacity];
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
call    3 returned 100%
       10:  183:  std::fill(table, table + capacity, nullptr);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       10:  184:  size = 0;
       10:  185:}
        -:  186:
function _ZNK9HashTable7getSizeEv called 242 returned 100% blocks executed 100%
      242:  187:size_t HashTable::getSize() const { return size; }
function _ZNK9HashTable11getCapacityEv called 24 returned 100% blocks executed 100%
       24:  188:size_t HashTable::getCapacity() const { return capacity; }
function _ZNK9HashTable5emptyEv called 2 returned 100% blocks executed 100%
        2:  189:bool HashTable::empty() const { return size == 0; }
        -:  190:
function _ZN9HashTable4swapERS_ called 2 returned 100% blocks executed 100%
        2:  191:void HashTable::swap(HashTable &other) {
        2:  192:  std::swap(other.table, table);
call    0 returned 100%
        2:  193:  std::swap(other.capacity, capacity);
call    0 returned 100%
        2:  194:  std::swap(other.size, size);
call    0 returned 100%
        2:  195:}
        -:  196:
        -:  197:/*--------OPERATORS---------*/
        -:  198:
        -:  199:// copy assignment
        -:  200:// 1) acquire new resources
        -:  201:// 2) release old resources
        -:  202:// 3) assign "new" resource values to the object
function _ZN9HashTableaSERKS_ called 6 returned 100% blocks executed 90%
        6:  203:HashTable &HashTable::operator=(const HashTable &other) {
        6:  204:  if (this == &other) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        2:  205:    return *this;
        -:  206:  }
        -:  207:
        -:  208:  // deallocating old resources
        4:  209:  deleteTable();
call    0 returned 100%
        -:  210:
        -:  211:  // copying data from other object
        4:  212:  capacity = other.capacity;
        4:  213:  size = other.size;
       4*:  214:  table = new HashNode *[capacity];
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
call    3 returned 100%
        -:  215:
        4:  216:  std::transform(other.table, other.table + capacity, table,
call    0 returned 100%
function _ZZN9HashTableaSERKS_ENKUlPKNS_8HashNodeEE_clES4_ called 40 returned 100% blocks executed 73%
       40:  217:                 [](const HashNode *node) {
       40:  218:                   return node != nullptr ? new HashNode(*node) : nullptr;
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
branch  8 never executed (fallthrough)
branch  9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed
call   12 never executed
        -:  219:                 });
        4:  220:  return *this;
        -:  221:}
        -:  222:
        -:  223:// move assignment
        -:  224:// 1) deallocate current object's data
        -:  225:// 2) copy other's data
        -:  226:// 3) mark other data as nullptr
function _ZN9HashTableaSEOS_ called 6 returned 100% blocks executed 100%
        6:  227:HashTable &HashTable::operator=(HashTable &&other) {
        6:  228:  if (this == &other) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        2:  229:    return *this;
        -:  230:  }
        -:  231:
        4:  232:  deleteTable();
call    0 returned 100%
        -:  233:
        4:  234:  table = other.table;
        4:  235:  size = other.size;
        4:  236:  capacity = other.capacity;
        -:  237:
        4:  238:  other.table = nullptr;
        4:  239:  other.capacity = 0;
        4:  240:  other.size = 0;
        -:  241:
        4:  242:  return *this;
        -:  243:}
        -:  244:
        -:  245:// returns value by k key
function _ZN9HashTableixERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 28 returned 100% blocks executed 100%
       28:  246:Value &HashTable::operator[](const Key &k) {
       28:  247:  const size_t hashed_index = hash(k);
call    0 returned 100%
       28:  248:  const size_t index = linearProbing(hashed_index, k, SearchType::SEARCH_FOR_KEY);
call    0 returned 100%
        -:  249:
       28:  250:  if (table[index] != nullptr && table[index]->key == k) {
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 86% (fallthrough)
branch  6 taken 14%
       24:  251:    return table[index]->value;
        -:  252:  }
        -:  253:
        4:  254:  table[index] = new HashNode();
call    0 returned 100%
call    1 returned 100%
        4:  255:  this->insert(table[index]->key, table[index]->value);
call    0 returned 100%
        -:  256:
        4:  257:  return table[index]->value;
        -:  258:}
        -:  259:
        -:  260:// comparison between tables
function _ZeqRK9HashTableS1_ called 420 returned 100% blocks executed 100%
      420:  261:bool operator==(const HashTable &a, const HashTable &b) {
      420:  262:  if (a.size != b.size) {
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
      410:  263:    return false;
        -:  264:  }
      684:  265:  for (size_t i = 0; i < a.capacity; i++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
      678:  266:    if (a.table[i] != nullptr) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        8:  267:      HashTable::HashNode *curNode = a.table[i];
        -:  268:      // no node with this key or has diff value
        8:  269:      if (!b.contains(curNode->key) || b.at(curNode->key) != curNode->value) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 50% (fallthrough)
branch  6 taken 50%
branch  7 taken 50% (fallthrough)
branch  8 taken 50%
        4:  270:        return false;
        -:  271:      }
        -:  272:    }
        -:  273:  }
        6:  274:  return true;
        -:  275:}
        -:  276:
function _ZneRK9HashTableS1_ called 410 returned 100% blocks executed 100%
      410:  277:bool operator!=(const HashTable &a, const HashTable &b) { return !(a == b); }
call    0 returned 100%
