        -:    0:Source:/home/krillin/code/nsu/23203_knyazkov/lab1/src/hashtable.cpp
        -:    0:Graph:/home/krillin/code/nsu/23203_knyazkov/lab1/test/build/CMakeFiles/TestCoverage.dir/src/all_tests.gcno
        -:    0:Data:/home/krillin/code/nsu/23203_knyazkov/lab1/test/build/CMakeFiles/TestCoverage.dir/src/all_tests.gcda
        -:    0:Runs:1
        -:    1:#include "hashtable.h"
        -:    2:
        -:    3:#include <algorithm>
        -:    4:#include <cstddef>
        -:    5:#include <cstdint>
        -:    6:#include <iostream>
        -:    7:#include <stdexcept>
        -:    8:
        -:    9:/*--------CONSTRUCTORS---------*/
        -:   10:
function _ZN9HashTableC2Ev called 36 returned 100% blocks executed 86%
       36:   11:HashTable::HashTable()
      36*:   12:    : capacity(DEF_CAPACITY), table(new HashNode *[capacity]) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
call    3 returned 100%
       36:   13:  std::fill(table, table + capacity, nullptr);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       36:   14:};
        -:   15:
function _ZN9HashTableD2Ev called 90 returned 100% blocks executed 100%
       90:   16:HashTable::~HashTable() {
       90:   17:  if (table != nullptr) {
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
       51:   18:    deleteTable();
call    0 returned 100%
        -:   19:  }
       90:   20:};
        -:   21:
function _ZN9HashTableC2ERKS_ called 1 returned 100% blocks executed 83%
        1:   22:HashTable::HashTable(const HashTable &other)
        1:   23:    : capacity(other.capacity), size(other.size),
       1*:   24:      table(new HashNode *[capacity]) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
call    3 returned 100%
        1:   25:  std::transform(
        1:   26:      other.table, other.table + capacity, table,
call    0 returned 100%
function _ZZN9HashTableC4ERKS_ENKUlPNS_8HashNodeEE_clES3_ called 10 returned 100% blocks executed 73%
       10:   27:      [](HashNode *node) { return node ? new HashNode(*node) : nullptr; });
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
branch  8 never executed (fallthrough)
branch  9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed
call   12 never executed
        1:   28:};
        -:   29:
function _ZN9HashTableC2Em called 53 returned 96% blocks executed 77%
       53:   30:HashTable::HashTable(size_t init_capacity) {
       53:   31:  if (init_capacity == 0) {
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        2:   32:    throw std::invalid_argument("nope");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 0%
call    5 never executed
        -:   33:  }
       51:   34:  capacity = init_capacity;
      51*:   35:  table = new HashNode *[capacity];
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
call    3 returned 100%
       51:   36:  std::fill(table, table + capacity, nullptr);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       51:   37:};
        -:   38:
function _ZN9HashTableC2EOS_ called 2 returned 100% blocks executed 100%
        2:   39:HashTable::HashTable(HashTable &&other)
        2:   40:    : capacity(other.capacity), size(other.size), table(other.table) {
        2:   41:  other.table = nullptr;
        2:   42:  other.capacity = 0;
        2:   43:  other.size = 0;
        2:   44:};
        -:   45:
        -:   46:/*--------METHODS---------*/
        -:   47:
        -:   48:// // magic 33 (hashing func for string key)
        -:   49:// size_t HashTable::hash(const Key &key) const {
        -:   50://   uint64_t hash = 5381;
        -:   51:
        -:   52://   for (auto c : key){
        -:   53://     hash = ((hash << 5) + hash) + c; // hash * 33 + c
        -:   54://   }
        -:   55:
        -:   56://   return hash % capacity;
        -:   57:// }
        -:   58:
function _ZNK9HashTable4hashERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 1639 returned 100% blocks executed 100%
     1639:   59:size_t HashTable::hash(const Key &key) const { return 1 % capacity; }
        -:   60:
function _ZNK9HashTable13getLoadFactorEv called 1401 returned 100% blocks executed 100%
     1401:   61:double HashTable::getLoadFactor() const {
     1401:   62:  return static_cast<double>(size) / (capacity);
        -:   63:}
        -:   64:
function _ZN9HashTable11deleteTableEv called 60 returned 100% blocks executed 100%
       60:   65:void HashTable::deleteTable() {
     1872:   66:  for (size_t i = 0; i < capacity; i++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
     1812:   67:    if (table[i] != nullptr) {
branch  0 taken 21% (fallthrough)
branch  1 taken 79%
      382:   68:      delete table[i];
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
        -:   69:    }
        -:   70:  }
       60:   71:  delete[] table;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
       60:   72:}
        -:   73:
        -:   74:// if MAX_LOAD_FACTOR is exceeded double the size
        -:   75:// and rehash everything to the new table
function _ZN9HashTable14rehashIfNeededEv called 1401 returned 100% blocks executed 91%
     1401:   76:void HashTable::rehashIfNeeded() {
     1401:   77:  const double load_factor = getLoadFactor();
call    0 returned 100%
     1401:   78:  if ((load_factor < MAX_LOAD_FACTOR) ||
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
       35:   79:      (capacity >= SIZE_MAX / CAPACITY_MULTIPLIER)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     1366:   80:    return;
        -:   81:  }
       35:   82:  const size_t old_capacity = capacity;
       35:   83:  capacity *= CAPACITY_MULTIPLIER;
       35:   84:  HashTable newTable(capacity);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:   85:
     1391:   86:  for (size_t i = 0; i < old_capacity; i++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
     1356:   87:    if (table[i] != nullptr) {
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
      818:   88:      newTable.insert(table[i]->key, table[i]->value);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
      818:   89:      delete table[i];
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
      818:   90:      table[i] = nullptr;
        -:   91:    }
        -:   92:  }
       35:   93:  delete[] table;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
       35:   94:  table = nullptr;
       35:   95:  std::swap(table, newTable.table);
call    0 returned 100%
       35:   96:}
call    0 returned 100%
call    1 never executed
        -:   97:
function _ZNK9HashTable4findERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 224 returned 100% blocks executed 100%
      224:   98:size_t HashTable::find(const Key &k) const {
      224:   99:  size_t hashed_index = hash(k);
call    0 returned 100%
      224:  100:  size_t index = hashed_index;
        -:  101:
      224:  102:  if (table[hashed_index] != nullptr && table[hashed_index]->key == k) {
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
call    2 returned 100%
branch  3 taken 73% (fallthrough)
branch  4 taken 27%
branch  5 taken 7% (fallthrough)
branch  6 taken 93%
       16:  103:    return index;
        -:  104:  } else {
      208:  105:    index = linearProbing(index, k, SearchType::SEARCH_FOR_KEY);
call    0 returned 100%
        -:  106:  }
      208:  107:  return index;
        -:  108:}
        -:  109:
        -:  110:// delete element by key k
        -:  111:// return if it was successuful (key is found and deleted)
function _ZN9HashTable5eraseERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 207 returned 100% blocks executed 100%
      207:  112:bool HashTable::erase(const Key &k) {
      207:  113:  const size_t index = find(k);
call    0 returned 100%
      207:  114:  if (index == capacity) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        1:  115:    return false;
        -:  116:  }
      206:  117:  std::clog << "> deleting " << k << std::endl;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  118:
      206:  119:  delete table[index];
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
      206:  120:  table[index] = nullptr; // node is deleted = nullptr
      206:  121:  size--;
      206:  122:  return true;
        -:  123:}
        -:  124:
        -:  125:// collission resolution:
        -:  126:// lineary go through table and search for empty/free or with the same key node
        -:  127:// index = capacity => index wasn't found (no bucket with key or buckets are
        -:  128:// full)
function _ZNK9HashTable13linearProbingEmRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS_10SearchTypeE called 1548 returned 100% blocks executed 100%
     1548:  129:size_t HashTable::linearProbing(size_t startIndex, Key const &key, SearchType searchT) const {
     1548:  130:  size_t curIndex = startIndex;
        -:  131:
    60144:  132:  for (size_t i = 0; i <= capacity; i++) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
    71069:  133:    if ((searchT == SearchType::SEARCH_FOR_NULLPTR && table[curIndex] == nullptr) ||
branch  0 taken 82% (fallthrough)
branch  1 taken 18%
branch  2 taken 97% (fallthrough)
branch  3 taken 3%
branch  4 taken 19% (fallthrough)
branch  5 taken 81%
branch  6 taken 3% (fallthrough)
branch  7 taken 97%
    15029:  134:        (searchT == SearchType::SEARCH_FOR_KEY && table[curIndex] != nullptr &&
branch  0 taken 37% (fallthrough)
branch  1 taken 63%
branch  2 taken 5% (fallthrough)
branch  3 taken 95%
     4097:  135:         table[curIndex]->key == key)) {
call    0 returned 100%
     1541:  136:      return curIndex; // Return the current index if the condition is met
        -:  137:    }
    58596:  138:    curIndex = (curIndex + i) % capacity;
        -:  139:  }
        7:  140:  return capacity;
        -:  141:}
        -:  142:
        -:  143:// insertion using linear probing collision resolution
        -:  144:// inserts node to container (return if it was success)
        -:  145:// otherwise, search for the first empty node (linear probing)
function _ZN9HashTable6insertERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERK5Value called 1401 returned 100% blocks executed 72%
     1401:  146:bool HashTable::insert(const Key &k, const Value &v) {
     1401:  147:  rehashIfNeeded();
call    0 returned 100%
     1401:  148:  size_t index = hash(k);
call    0 returned 100%
        -:  149:  // if node is not empty or doesn't have the same key
     1401:  150:  if (!(table[index] == nullptr) && !(table[index]->key == k)) {
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 95% (fallthrough)
branch  6 taken 5%
     1326:  151:    index = linearProbing(index, k, SearchType::SEARCH_FOR_NULLPTR); // collission resolution
call    0 returned 100%
        -:  152:  }
        -:  153:  // if index was found
     1401:  154:  if (index != capacity) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1401:  155:    if (table[index] == nullptr) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1401:  156:      table[index] = new HashNode(k, v);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
branch  9 never executed (fallthrough)
branch 10 never executed
call   11 never executed
     1401:  157:      ++size;
     1401:  158:      return true;
        -:  159:    } else {
    #####:  160:      return false;
        -:  161:    }
        -:  162:  }
    #####:  163:  return false;
        -:  164:}
        -:  165:
function _ZNK9HashTable2atERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 8 returned 75% blocks executed 71%
        8:  166:const Value &HashTable::at(const Key &k) const {
        8:  167:  const size_t index = find(k);
call    0 returned 100%
        8:  168:  if (index == capacity) {
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        2:  169:    throw std::runtime_error("Key not found: " + k);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 0%
call    9 never executed
call   10 never executed
        -:  170:  }
        6:  171:  return table[index]->value;
        -:  172:}
        -:  173:
function _ZN9HashTable2atERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 4 returned 50% blocks executed 100%
        4:  174:Value &HashTable::at(const Key &k) {
        4:  175:  return const_cast<Value &>(static_cast<const HashTable *>(this)->at(k));
call    0 returned 50%
        -:  176:}
        -:  177:
function _ZNK9HashTable8containsERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 9 returned 100% blocks executed 100%
        9:  178:bool HashTable::contains(const Key &key) const {
        9:  179:  return (find(key) != capacity);
call    0 returned 100%
        -:  180:}
        -:  181:
function _ZN9HashTable5clearEv called 5 returned 100% blocks executed 88%
        5:  182:void HashTable::clear() {
        5:  183:  deleteTable();
call    0 returned 100%
       5*:  184:  table = new HashNode *[capacity];
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
call    3 returned 100%
        5:  185:  std::fill(table, table + capacity, nullptr);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        5:  186:  size = 0;
        5:  187:}
        -:  188:
function _ZNK9HashTable7getSizeEv called 169 returned 100% blocks executed 100%
      169:  189:size_t HashTable::getSize() const { return size; }
function _ZNK9HashTable11getCapacityEv called 60 returned 100% blocks executed 100%
       60:  190:size_t HashTable::getCapacity() const { return capacity; }
function _ZNK9HashTable5emptyEv called 1 returned 100% blocks executed 100%
        1:  191:bool HashTable::empty() const { return size == 0; }
        -:  192:
function _ZN9HashTable4swapERS_ called 1 returned 100% blocks executed 100%
        1:  193:void HashTable::swap(HashTable &other) {
        1:  194:  std::swap(other.table, table);
call    0 returned 100%
        1:  195:  std::swap(other.capacity, capacity);
call    0 returned 100%
        1:  196:  std::swap(other.size, size);
call    0 returned 100%
        1:  197:}
        -:  198:
        -:  199:/*--------OPERATORS---------*/
        -:  200:
        -:  201:// copy assignment
        -:  202:// 1) acquire new resources
        -:  203:// 2) release old resources
        -:  204:// 3) assign "new" resource values to the object
function _ZN9HashTableaSERKS_ called 3 returned 100% blocks executed 90%
        3:  205:HashTable &HashTable::operator=(const HashTable &other) {
        3:  206:  if (this == &other) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        1:  207:    return *this;
        -:  208:  }
        -:  209:
        -:  210:  // deallocating old resources
        2:  211:  deleteTable();
call    0 returned 100%
        -:  212:
        -:  213:  // copying data from other object
        2:  214:  capacity = other.capacity;
        2:  215:  size = other.size;
       2*:  216:  table = new HashNode *[capacity];
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
call    3 returned 100%
        -:  217:
        2:  218:  std::transform(other.table, other.table + capacity, table,
call    0 returned 100%
function _ZZN9HashTableaSERKS_ENKUlPKNS_8HashNodeEE_clES4_ called 20 returned 100% blocks executed 73%
       20:  219:                 [](const HashNode *node) {
       20:  220:                   return node != nullptr ? new HashNode(*node) : nullptr;
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
branch  8 never executed (fallthrough)
branch  9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed
call   12 never executed
        -:  221:                 });
        2:  222:  return *this;
        -:  223:}
        -:  224:
        -:  225:// move assignment
        -:  226:// 1) deallocate current object's data
        -:  227:// 2) copy other's data
        -:  228:// 3) mark other data as nullptr
function _ZN9HashTableaSEOS_ called 3 returned 100% blocks executed 100%
        3:  229:HashTable &HashTable::operator=(HashTable &&other) {
        3:  230:  if (this == &other) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        1:  231:    return *this;
        -:  232:  }
        -:  233:
        2:  234:  deleteTable();
call    0 returned 100%
        -:  235:
        2:  236:  table = other.table;
        2:  237:  size = other.size;
        2:  238:  capacity = other.capacity;
        -:  239:
        2:  240:  other.table = nullptr;
        2:  241:  other.capacity = 0;
        2:  242:  other.size = 0;
        -:  243:
        2:  244:  return *this;
        -:  245:}
        -:  246:
        -:  247:// returns value by k key
function _ZN9HashTableixERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 14 returned 100% blocks executed 100%
       14:  248:Value &HashTable::operator[](const Key &k) {
       14:  249:  const size_t hashed_index = hash(k);
call    0 returned 100%
       14:  250:  const size_t index = linearProbing(hashed_index, k, SearchType::SEARCH_FOR_KEY);
call    0 returned 100%
        -:  251:
       14:  252:  if (table[index] != nullptr && table[index]->key == k) {
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 86% (fallthrough)
branch  6 taken 14%
       12:  253:    return table[index]->value;
        -:  254:  }
        -:  255:
        2:  256:  table[index] = new HashNode();
call    0 returned 100%
call    1 returned 100%
        2:  257:  this->insert(table[index]->key, table[index]->value);
call    0 returned 100%
        -:  258:
        2:  259:  return table[index]->value;
        -:  260:}
        -:  261:
        -:  262:// comparison between tables
function _ZeqRK9HashTableS1_ called 210 returned 100% blocks executed 100%
      210:  263:bool operator==(const HashTable &a, const HashTable &b) {
      210:  264:  if (a.size != b.size) {
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
      205:  265:    return false;
        -:  266:  }
      342:  267:  for (size_t i = 0; i < a.capacity; i++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
      339:  268:    if (a.table[i] != nullptr) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        4:  269:      HashTable::HashNode *curNode = a.table[i];
        -:  270:      // no node with this key or has diff value
        4:  271:      if (!b.contains(curNode->key) || b.at(curNode->key) != curNode->value) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 50% (fallthrough)
branch  6 taken 50%
branch  7 taken 50% (fallthrough)
branch  8 taken 50%
        2:  272:        return false;
        -:  273:      }
        -:  274:    }
        -:  275:  }
        3:  276:  return true;
        -:  277:}
        -:  278:
function _ZneRK9HashTableS1_ called 205 returned 100% blocks executed 100%
      205:  279:bool operator!=(const HashTable &a, const HashTable &b) { return !(a == b); }
call    0 returned 100%
