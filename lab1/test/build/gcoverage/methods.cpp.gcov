        -:    0:Source:/home/krillin/code/nsu/23203_knyazkov/lab1/src/methods.cpp
        -:    1:#include "hashtable.h"
        -:    2:#include <cstddef>
        -:    3:#include <stdexcept>
        -:    4:
        -:    5:// magic 33 (hashing func for string key)
function _ZNK9HashTable4hashERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 134 returned 100% blocks executed 100%
      134:    6:int HashTable::hash(const Key &key) const {
      134:    7:  unsigned long hash = 5381;
        -:    8:
      536:    9:  for (auto c : key)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 75%
branch  5 taken 25% (fallthrough)
      402:   10:    hash = ((hash << 5) + hash) + c; // hash * 33 + c
call    0 returned 100%
        -:   11:
      134:   12:  return hash % capacity;
        -:   13:}
        -:   14:
function _ZN9HashTable13getLoadFactorERKdS1_ called 76 returned 100% blocks executed 100%
       76:   15:double HashTable::getLoadFactor(double const &size, double const &capacity) {
       76:   16:  return size / capacity;
        -:   17:}
        -:   18:
        -:   19:// if MAX_LOAD_FACTOR is exceeded double the size
        -:   20:// and rehash everything to the new table
function _ZN9HashTable14rehashIfNeededEv called 76 returned 100% blocks executed 91%
       76:   21:void HashTable::rehashIfNeeded() {
        -:   22:  double load_factor =
       76:   23:      getLoadFactor(static_cast<double>(size), static_cast<double>(capacity));
call    0 returned 100%
       76:   24:  if (load_factor < MAX_LOAD_FACTOR)
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
       73:   25:    return;
        -:   26:
        3:   27:  capacity *= 2;
      51*:   28:  HashNode **newTable = new HashNode *[capacity]();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
call    3 returned 100%
branch  4 taken 94%
branch  5 taken 6% (fallthrough)
       51:   29:  for (int i = 0; i < capacity; i++)
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
       48:   30:    newTable[i] = new HashNode();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
        -:   31:
       27:   32:  for (int i = 0; i < capacity / 2; i++) {
branch  0 taken 89%
branch  1 taken 11% (fallthrough)
       24:   33:    if (table[i] != nullptr) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       24:   34:      int newIndex = hash(table[i]->key);
call    0 returned 100%
       24:   35:      if (newTable[newIndex] != nullptr) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       24:   36:        delete newTable[newIndex]; // Free the existing node
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
        -:   37:      }
       24:   38:      newTable[newIndex] = std::move(table[i]);
call    0 returned 100%
        -:   39:    }
       24:   40:    table[i] = nullptr;
        -:   41:  }
        3:   42:  delete[] table;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        3:   43:  table = newTable;
        -:   44:}
        -:   45:
        -:   46:// delete element by key k
        -:   47:// return if it was successuful (key is found and deleted)
function _ZN9HashTable5eraseERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 6 returned 100% blocks executed 88%
        6:   48:bool HashTable::erase(const Key &k) {
        6:   49:  int hashed_index = hash(k);
call    0 returned 100%
        6:   50:  int index = -1;
        6:   51:  if (table[hashed_index]->key == k) {
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
        4:   52:    index = hashed_index;
        -:   53:  } else {
        2:   54:    index = find(k);
call    0 returned 100%
        -:   55:  }
        -:   56:
        6:   57:  if (index == -1)
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        2:   58:    return false;
        -:   59:
        4:   60:  delete table[index];
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
        4:   61:  HashNode *empty = new HashNode();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
        4:   62:  table[index] = empty;
        4:   63:  size--;
        4:   64:  return true;
        -:   65:}
        -:   66:
        -:   67:// collission resolution
        -:   68:// lineary go through table and search for empty/free or with the same key node
function _ZNK9HashTable13linearProbingEiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 15 returned 100% blocks executed 100%
       15:   69:int HashTable::linearProbing(int startIndex, Key key) const {
       15:   70:  int i = startIndex;
       15:   71:  ++startIndex;
       27:   72:  while (i != startIndex) {
branch  0 taken 63%
branch  1 taken 37% (fallthrough)
       17:   73:    if (table[i] == nullptr || table[i]->key.empty() || table[i]->key == key) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 82% (fallthrough)
branch  4 taken 18%
call    5 returned 100%
branch  6 taken 14% (fallthrough)
branch  7 taken 86%
branch  8 taken 29% (fallthrough)
branch  9 taken 71%
        5:   74:      return i;
        -:   75:    }
       12:   76:    i = (i + 1) % capacity;
        -:   77:  }
       10:   78:  return -1; // Indicate that no suitable index was found (should not happen if
        -:   79:             // table is not full)
        -:   80:}
        -:   81:
        -:   82:// insertion using linear probing collision resolution
        -:   83:// inserts node to container (return if it was success)
        -:   84:// otherwise, search for the first empty node (linear probing)
function _ZN9HashTable6insertERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERK5Value called 76 returned 100% blocks executed 78%
       76:   85:bool HashTable::insert(const Key &k, const Value &v) {
       76:   86:  rehashIfNeeded();
call    0 returned 100%
       76:   87:  if (size == capacity) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   88:    return false;
        -:   89:  }
       76:   90:  int index = -1;
       76:   91:  int hashed_index = hash(k);
call    0 returned 100%
        -:   92:
        -:   93:  // if node is empty or has the same key
       86:   94:  if (table[hashed_index] == nullptr || table[hashed_index]->key.empty() ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 13% (fallthrough)
branch  4 taken 87%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
branch  7 taken 87% (fallthrough)
branch  8 taken 13%
       10:   95:      table[hashed_index]->key == k) {
call    0 returned 100%
       66:   96:    index = hashed_index;
        -:   97:  } else { // collission resolution
       10:   98:    index = linearProbing((hashed_index + 1) % capacity, k);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
call    5 never executed
        -:   99:  }
       76:  100:  if (index != -1) {
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
       68:  101:    HashNode *newNode = new HashNode(k, v);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
branch  9 never executed (fallthrough)
branch 10 never executed
call   11 never executed
       68:  102:    table[index] = newNode;
       68:  103:    ++size;
       68:  104:    return true;
        -:  105:  }
        8:  106:  return false;
        -:  107:}
        -:  108:
function _ZNK9HashTable2atERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 3 returned 67% blocks executed 71%
        3:  109:const Value &HashTable::at(const Key &k) const {
        3:  110:  int index = find(k);
call    0 returned 100%
        -:  111:
        3:  112:  if (index == -1)
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        1:  113:    throw std::runtime_error("Key not found: " + k);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 0%
call    9 never executed
call   10 never executed
        -:  114:
        2:  115:  return table[index]->value;
        -:  116:}
        -:  117:
function _ZN9HashTable2atERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 3 returned 67% blocks executed 100%
        3:  118:Value &HashTable::at(const Key &k) {
        3:  119:  return const_cast<Value &>(static_cast<const HashTable *>(this)->at(k));
call    0 returned 67%
        -:  120:}
        -:  121:
function _ZNK9HashTable8containsERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 4 returned 100% blocks executed 100%
        4:  122:bool HashTable::contains(const Key &key) const { return (find(key) != -1); }
call    0 returned 100%
        -:  123:
function _ZN9HashTable5clearEv called 3 returned 100% blocks executed 92%
        3:  124:void HashTable::clear() {
        3:  125:  if (table == nullptr) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  126:    return;
        -:  127:  }
        -:  128:
       15:  129:  for (size_t i = 0; i < capacity; ++i) {
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
       12:  130:    if (table[i] != nullptr){
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
       11:  131:      delete table[i];
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
       11:  132:      table[i] = nullptr;
        -:  133:    }
        -:  134:  }
        3:  135:  size = 0;
        -:  136:}
        -:  137:
function _ZNK9HashTable7getSizeEv called 21 returned 100% blocks executed 100%
       21:  138:size_t HashTable::getSize() const { return size; }
function _ZNK9HashTable11getCapacityEv called 35 returned 100% blocks executed 100%
       35:  139:size_t HashTable::getCapacity() const { return capacity; }
        -:  140:
function _ZNK9HashTable5emptyEv called 2 returned 100% blocks executed 100%
        2:  141:bool HashTable::empty() const { return size == 0; }
        -:  142:
function _ZNK9HashTable4findERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 13 returned 100% blocks executed 87%
       13:  143:int HashTable::find(const Key &k) const {
       13:  144:  int index = hash(k);
call    0 returned 100%
        -:  145:
       13:  146:  if (table[index]->key == k)
call    0 returned 100%
branch  1 taken 62% (fallthrough)
branch  2 taken 38%
        8:  147:    return index;
        -:  148:
        5:  149:  if (table[index] == nullptr)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  150:    return -1;
        -:  151:
        5:  152:  int i = (index + 1) % capacity;
       29:  153:  while (i != index && table[i] != nullptr) {
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
       24:  154:    if (table[i]->key == k) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  155:      return i;
        -:  156:    }
       24:  157:    i = (i + 1) % capacity;
        -:  158:  }
        5:  159:  return -1;
        -:  160:}
        -:  161:
function _ZN9HashTable4swapERS_ called 1 returned 100% blocks executed 100%
        1:  162:void HashTable::swap(HashTable &other) {
        -:  163:  //std::swap(other.table, table);
        1:  164:  HashNode **otherT = other.table;
        1:  165:  other.table = table;
        1:  166:  table = otherT;
        -:  167:
        1:  168:  std::swap(other.capacity, capacity);
call    0 returned 100%
        1:  169:  std::swap(other.size, size);
call    0 returned 100%
        1:  170:}
