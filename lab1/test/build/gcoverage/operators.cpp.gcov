        -:    0:Source:/home/krillin/code/nsu/23203_knyazkov/lab1/src/operators.cpp
        -:    1:#include "hashtable.h"
        -:    2:
        -:    3:
        -:    4:// copy assignment
        -:    5:// 1) acquire new resources
        -:    6:// 2) release old resources
        -:    7:// 3) assign "new" resource values to the object
function _ZN9HashTableaSERKS_ called 9 returned 100% blocks executed 86%
        9:    8:HashTable &HashTable::operator=(const HashTable &other) {
        9:    9:  if (this == &other)
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        3:   10:    return *this;
        -:   11:
        -:   12:  // deallocating old resources
        -:   13:
       66:   14:  for (size_t i = 0; i < capacity; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       60:   15:    if (table[i] != nullptr)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       60:   16:      delete table[i];
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
        -:   17:  }
        6:   18:  delete[] table;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:   19:
        -:   20:  // copying data from other object
        6:   21:  capacity = other.capacity;
        6:   22:  size = other.size;
        -:   23:
       6*:   24:  table = new HashNode *[capacity];
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
call    3 returned 100%
        -:   25:
       66:   26:  for (size_t i = 0; i < capacity; ++i) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       60:   27:    if (other.table[i] != nullptr) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       60:   28:      table[i] = new HashNode(*other.table[i]);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
        -:   29:    } else {
    #####:   30:      table[i] = nullptr;
        -:   31:    }
        -:   32:  }
        -:   33:
        6:   34:  return *this;
        -:   35:}
        -:   36:
        -:   37:// move assignment
        -:   38:// 1) deallocate current object's data
        -:   39:// 2) copy other's data
        -:   40:// 3) mark other data as nullptr
function _ZN9HashTableaSEOS_ called 12 returned 100% blocks executed 100%
       12:   41:HashTable &HashTable::operator=(HashTable &&other) {
       12:   42:  if (this == &other) // sus
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        3:   43:    return *this;
        -:   44:
       99:   45:  for (size_t i = 0; i < capacity; ++i) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       90:   46:    if (table[i] != nullptr)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       90:   47:      delete table[i];
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
        -:   48:  }
        9:   49:  delete[] table;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:   50:
        9:   51:  table = other.table;
        9:   52:  size = other.size;
        9:   53:  capacity = other.capacity;
        -:   54:
        9:   55:  other.table = nullptr;
        9:   56:  other.capacity = 0;
        9:   57:  other.size = 0;
        -:   58:
        9:   59:  return *this;
        -:   60:}
        -:   61:
        -:   62:// returns value by k key
function _ZN9HashTableixERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 45 returned 100% blocks executed 88%
       45:   63:Value &HashTable::operator[](const Key &k) {
       45:   64:  int index = hash(k);
call    0 returned 100%
        -:   65:
       45:   66:  if (table[index] != nullptr && table[index]->key == k) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 87% (fallthrough)
branch  4 taken 13%
branch  5 taken 87% (fallthrough)
branch  6 taken 13%
       39:   67:    return table[index]->value;
        -:   68:  }
        -:   69:
        6:   70:  HashNode *newNode = new HashNode(); 
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
        6:   71:  this->insert(newNode->key, newNode->value);
call    0 returned 100%
        -:   72:
        -:   73:  // Return the newly inserted value
        6:   74:  return newNode->value;
        -:   75:}
        -:   76:
        -:   77:// comparassion between tables
function _ZeqRK9HashTableS1_ called 15 returned 100% blocks executed 100%
       15:   78:bool operator==(const HashTable &a, const HashTable &b) {
       15:   79:  if (a.size != b.size) {
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
        6:   80:    return false;
        -:   81:  }
        -:   82:
       51:   83:  for (size_t i = 0; i < a.capacity; i++) {
branch  0 taken 88%
branch  1 taken 12% (fallthrough)
       45:   84:    if (a.table[i] != nullptr) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       90:   85:      if (b.table[i] == nullptr || b.table[i]->key != a.table[i]->key ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 7% (fallthrough)
branch  6 taken 93%
branch  7 taken 7% (fallthrough)
branch  8 taken 93%
       45:   86:          b.table[i]->value != a.table[i]->value) {
call    0 returned 100%
        3:   87:        return false;
        -:   88:      }
        -:   89:    }
        -:   90:  }
        6:   91:  return true;
        -:   92:}
        -:   93:
function _ZneRK9HashTableS1_ called 6 returned 100% blocks executed 100%
        6:   94:bool operator!=(const HashTable &a, const HashTable &b) { return !(a == b); }
call    0 returned 100%
